/**
 * Tests assume standard Windows 7 environment.
 **/

//JSLint static code analysis options
/*jslint node:true, nomen:true, stupid:true, sloppy:true, plusplus:true, indent:4, white:true */
/*global describe, beforeEach, afterEach, it, expect*/

var sfs = require('scopedfs'),
    fs = require('fs'),
    path = require('path'),

    NOTEPAD = 'notepad.exe',
    //SYSTEM_INI = 'system.ini',
    REPEAT_CNT = 5,

    SFS_DIR = 'node_modules/scopedfs',
    TEST_DIR = SFS_DIR + '/test',
    TEST_FILE = SFS_DIR + '/test/test.spec.js',
    TEST_BAT = SFS_DIR + '/test/runTest.bat',
    REGEX_PACKAGE_JSON = /package\.json/,
    REGEX_PKG_NAME = /[\\\/]([^\\\/]+)[\\\/]package\.json$/m,
    fileCntInSfs = fs.readdirSync(SFS_DIR).length,

    winDir = process.env.windir,
    rootDrive = winDir.substring(0, 3);

process.on('uncaughtException', function(err) {
    console.log('WRN: Uncaught exception ignored; check your codes!', err);
    console.log(err.stack);
});

//instrument fs.readFile, so we can tell when it is called, and how many times its is called
var readFileCallCnt = 0;
fs.readFile_real = fs.readFile;
fs.readFile = function() {
    ++readFileCallCnt;
    fs.readFile_real.apply(this, arguments);
};

describe('scopedfs - instantiation:', function() {
//    beforeEach(function() {
//        //do some initialization before running each spec
//    });
//
//    afterEach(function() {
//        //do some cleanup after running each spec
//    });

    it('default: all drives access',
        function() {
            expect(!!sfs.statSync(winDir)).toBeTruthy();
            expect(!!sfs.statSync(rootDrive)).toBeTruthy();
        });
    it('new scope, no input parameters: defaults to all drives access',
        function() {
            var f = sfs.scoped();
            expect(!!f.statSync('node_modules/scopedfs/lib/scopedfs.js')).toBeTruthy();
            //can access root drive, windows, users folders
            expect(!!sfs.statSync(winDir)).toBeTruthy();
            expect(!!sfs.statSync(rootDrive)).toBeTruthy();
            expect(!!sfs.statSync(rootDrive + '/users')).toBeTruthy();
        });
    it('lock path to windows folder',
        function(done) {
            var f = sfs.scoped(winDir, true);
            f.stat(rootDrive, function(err, stats) {
                expect(!err).toBeFalsy(); //can't access root drive when lock to windows folder
                expect(stats).toBeUndefined();
                f.stat(NOTEPAD, function(err, stats) {
                    expect(!err).toBeTruthy(); //can access notepad in windows folder
                    expect(stats).toBeDefined();
                    f.stat('../users', function(err, stats) {
                        expect(!err).toBeFalsy();  //can't use '..' to reach 'above' locked folder
                        expect(stats).toBeUndefined();
                        done();
                    });
                });
            });
        });
});

describe('scopedfs - readFile() with cache:', function() {
    beforeEach(function() {
        //do some initialization before running each spec
        sfs.purgeCache();
        readFileCallCnt = 0; //reset counter
    });

    it("options object specifies 'binary' encoding",
        function(done) {
            var f = sfs.scoped(winDir, true);
            f.readFile(NOTEPAD, {encoding:'binary'}, true, function(err, data) {
                expect(!err).toBeTruthy(); //can access notepad in windows folder
                expect(data).toBeDefined();
                expect(typeof data).toEqual('string'); //Note: even though encoding is specified as 'binary', data is returned as string!
                expect(data.length).toBeGreaterThan(0);
                done();
            });
        });

    it("'null' encoding, i.e. retrieve data as a Buffer",
        function(done) {
            var f = sfs.scoped(winDir, true);
            f.readFile(NOTEPAD, null, true, function(err, data) {
                expect(!err).toBeTruthy(); //can access notepad in windows folder
                expect(data).toBeDefined();
                expect(data instanceof Buffer).toBeTruthy(); //Note: encoding must be null to get data in a Buffer!
                expect(data.length).toBeGreaterThan(0);
                done();
            });
        });

    it("'utf8' encoding; read " + REPEAT_CNT + " times",
        function(done) {
            var f = sfs.scoped(winDir, true),
                returnCnt = 0, i;
            function callback(err, data) {
                expect(!err).toBeTruthy(); //can access notepad in windows folder
                expect(data).toBeDefined();
                expect(typeof data).toEqual('string');
                expect(data.length).toBeGreaterThan(0);
                expect(readFileCallCnt).toBe(1);  //no matter how many times the same file is read, only 1 (system) fs.readFile call should have been made
                if (++returnCnt >= REPEAT_CNT)
                {
                    done();
                }
            }
            //read the same file REPEAT_CNT times
            for (i = 0; i < REPEAT_CNT; ++i)
            {
                f.readFile(NOTEPAD, 'utf8', true, callback);
            }
        });

    it("different options, different cache. Cache is also global.",
        function(done) {
            var f = sfs.scoped(winDir, true);
            f.readFile(NOTEPAD, {encoding:'binary'}, true, function(err, data) {
                expect(!err).toBeTruthy(); //can access notepad in windows folder
                expect(data).toBeDefined();
                expect(typeof data).toEqual('string'); //Note: even though encoding is specified as 'binary', data is returned as string!
                expect(data.length).toBeGreaterThan(0);
                expect(readFileCallCnt).toBe(1);
                    //use different options
                    f.readFile(NOTEPAD, 'binary', true, function(err, data) { //Note: considered different from earlier, even if both encoding are the same
                        expect(!err).toBeTruthy();
                        expect(data).toBeDefined();
                        expect(typeof data).toEqual('string');
                        expect(data.length).toBeGreaterThan(0);
                        expect(readFileCallCnt).toBe(2);
                        f.readFile(NOTEPAD, 'utf8', true, function(err, data) {
                            expect(!err).toBeTruthy();
                            expect(data).toBeDefined();
                            expect(typeof data).toEqual('string');
                            expect(data.length).toBeGreaterThan(0);
                            expect(readFileCallCnt).toBe(3);
                            f.readFile(NOTEPAD, null, true, function(err, data) {
                                expect(!err).toBeTruthy();
                                expect(data).toBeDefined();
                                expect(data instanceof Buffer).toBeTruthy();
                                expect(data.length).toBeGreaterThan(0);
                                expect(readFileCallCnt).toBe(4);
                                //get one of the earlier cached copies & also demonstrate cache is 'global'
                                var f2 = sfs.scoped(winDir, true);
                                f2.readFile(NOTEPAD, 'binary', true, function(err, data) {
                                    expect(!err).toBeTruthy();
                                    expect(data).toBeDefined();
                                    expect(typeof data).toEqual('string');
                                    expect(data.length).toBeGreaterThan(0);
                                    expect(readFileCallCnt).toBe(4); //no change, as retrieved from cache
                                    done();
                                });
                            });
                        });
                    });
            });
        });
});

describe('scopedfs - purgeCache():', function() {
    beforeEach(function() {
        //do some initialization before running each spec
        sfs.purgeCache();
        readFileCallCnt = 0; //reset counter
    });

    it("refetch file after purge (using local scoped instance)",
        function(done) {
            var f = sfs.scoped(winDir, true),
                returnCnt = 0, i;
            function callback(err, data) {
                expect(!err).toBeTruthy(); //can access notepad in windows folder
                expect(data).toBeDefined();
                expect(typeof data).toEqual('string');
                expect(data.length).toBeGreaterThan(0);
                expect(readFileCallCnt).toBe(1);  //no matter how many times the same file is read, only 1 (system) fs.readFile call should have been made
                if (++returnCnt >= REPEAT_CNT)
                {
                    f.purgeCache();
                    f.readFile(NOTEPAD, 'utf8', true, function(err, data) {
                        expect(!err).toBeTruthy();
                        expect(data).toBeDefined();
                        expect(typeof data).toEqual('string');
                        expect(data.length).toBeGreaterThan(0);
                        expect(readFileCallCnt).toBe(2);  //refetch as cache was purged
                        done();
                    });
                }
            }
            //read the same file REPEAT_CNT times
            for (i = 0; i < REPEAT_CNT; ++i)
            {
                f.readFile(NOTEPAD, 'utf8', true, callback);
            }
        });

    it("refetch file twice after purge (using global instance)",
        function(done) {
            var f = sfs.scoped(winDir, true),
                returnCnt = 0, i;
            function callback(err, data) {
                expect(!err).toBeTruthy(); //can access notepad in windows folder
                expect(data).toBeDefined();
                expect(typeof data).toEqual('string');
                expect(data.length).toBeGreaterThan(0);
                expect(readFileCallCnt).toBe(1);  //no matter how many times the same file is read, only 1 (system) fs.readFile call should have been made
                if (++returnCnt >= REPEAT_CNT)
                {
                    sfs.purgeCache(); //using global instance
                    f.readFile(NOTEPAD, 'utf8', true, function(err, data) {
                        expect(!err).toBeTruthy();
                        expect(data).toBeDefined();
                        expect(typeof data).toEqual('string');
                        expect(data.length).toBeGreaterThan(0);
                        expect(readFileCallCnt).toBe(2);  //refetch as cache was purged
                            f.readFile(NOTEPAD, 'utf8', true, function(err, data) {
                                expect(!err).toBeTruthy();
                                expect(data).toBeDefined();
                                expect(typeof data).toEqual('string');
                                expect(data.length).toBeGreaterThan(0);
                                expect(readFileCallCnt).toBe(2);  //file is back in cache, so no new call to fs.readFile
                                done();
                            });
                    });
                }
            }
            //read the same file REPEAT_CNT times
            for (i = 0; i < REPEAT_CNT; ++i)
            {
                f.readFile(NOTEPAD, 'utf8', true, callback);
            }
        });
});

describe('scopedfs - readFile() without cache:', function() {
    it("'utf8' encoding, read " + REPEAT_CNT + " times",
        function(done) {
            readFileCallCnt = 0; //reset counter

            var f = sfs.scoped(winDir, true),
                returnCnt = 0, i;
            function callback(err, data) {
                expect(!err).toBeTruthy(); //can access notepad in windows folder
                expect(data).toBeDefined();
                expect(typeof data).toEqual('string');
                expect(data.length).toBeGreaterThan(0);
                if (++returnCnt >= REPEAT_CNT)
                {
                    expect(readFileCallCnt).toBe(REPEAT_CNT);  //no cache, so multiple calls expected
                    done();
                }
            }
            //read the same file REPEAT_CNT times
            for (i = 0; i < REPEAT_CNT; ++i)
            {
                f.readFile(NOTEPAD, 'utf8', false, callback);
            }
        });
});

describe('scopedfs - readFile() on non-existent file:', function() {
    //Note: we can't really inspect scopedfs' internal workings to see if cache is really purged.
    // Thus, we're just checking that it didn't crash.
    it("purgeCache - initial call",
        function() {
            sfs.purgeCache();
        });

    it("proper error returned, and not exception thrown",
        function(done) {
            var f = sfs.scoped(winDir, true);
            f.readFile('*** no such file ***', null, true, function(err, data) {
                expect(!err).toBeFalsy(); //can't access non-existent file
                expect(data).toBeUndefined();
                done();
            });
        });

    //Just checking again after some data has been cached
    it("purgeCache - after there may be some content",
        function() {
            sfs.purgeCache();
            var f = sfs.scoped(winDir, true);
            f.purgeCache();
        });
});

describe('scopedfs - readFile() with incomplete input parameters:', function() {
    it("path only",
        function(done) {
            var f = sfs.scoped(winDir, true);
            f.readFile(NOTEPAD);
            done(); //ensure no crash
        });

    it("invalid path with encoding, cache, callback",
        function(done) {
            var f = sfs.scoped(winDir, true);
            f.readFile(null, null, true, function(err, data) {
                expect(!err).toBeFalsy();
                expect(data).toBeUndefined();
                done();
            });
        });

    it("path, callback, i.e. encoding defaults to null, cache to false",
        function(done) {
            var f = sfs.scoped(winDir, true);
            f.readFile(NOTEPAD, function(err, data) {
                expect(!err).toBeTruthy();
                expect(data).toBeDefined();
                expect(data instanceof Buffer).toBeTruthy();
                expect(data.length).toBeGreaterThan(0);
                done();
            });
        });

    it("path, cache:true, callback, i.e. encoding defaults to null",
        function(done) {
            var f = sfs.scoped(winDir, true);
            f.readFile(NOTEPAD, true, function(err, data) {
                expect(!err).toBeTruthy();
                expect(data).toBeDefined();
                expect(data instanceof Buffer).toBeTruthy();
                expect(data.length).toBeGreaterThan(0);
                done();
            });
        });

    it("path, encoding of 'ascii', callback, i.e. cache defaults to false",
        function(done) {
            var f = sfs.scoped(winDir, true);
            f.readFile(NOTEPAD, 'ascii', function(err, data) {
                expect(!err).toBeTruthy();
                expect(data).toBeDefined();
                expect(typeof data).toEqual('string');
                expect(data.length).toBeGreaterThan(0);
                done();
            });
        });

    it("path, encoding of 'utf8', cache:true, no callback (but cache file anyway)",
        function(done) {
            var f = sfs.scoped(winDir, true);
            f.readFile(NOTEPAD, 'utf8', true);
            done(); //ensure no crash
        });
});

describe('scopedfs - fileutils addtions:', function() {
    it("eachFileOrDirectory()",
        function(done) {
            //We'll try to find the 3 files in our test folder
            var f = sfs.scoped(SFS_DIR, true),
                fileCnt = 0, fileCnt2 = 0,
                foundTestDir = false,
                foundTestFile = false,
                foundTestBat = false,
                otherFile = false;
            f.eachFileOrDirectory('.', true, function(err, file, stat) {
                expect(!err).toBeTruthy();
                ++fileCnt;
                file = path.normalize(file).replace(/\\/g, '/');
                if (stat.isDirectory())
                {
                    if (file === TEST_DIR)
                    {
                        foundTestDir = true;
                    }
                    else
                    {
                        otherFile = true;
                    }
                }
                else
                {
                    if (file === TEST_BAT)
                    {
                        foundTestBat = true;
                    }
                    else if (file === TEST_FILE)
                    {
                        foundTestFile = true;
                    }
                    else
                    {
                        otherFile = true;
                    }
                }
            }, function() {
                expect(foundTestDir && foundTestFile && foundTestBat && otherFile).toBeTruthy();
                expect(fileCntInSfs).toBeLessThan(fileCnt); //compare against fs.readdirSync
                done();
            });

            //no recursion
            f.eachFileOrDirectory('.', false, function(err, file, stat) {
                expect(!err).toBeTruthy();
                ++fileCnt2;
            }, function() {
                expect(fileCntInSfs).toEqual(fileCnt2); //compare against fs.readdirSync
                done();
            });
        });

    it("eachFile()",
        function(done) {
            //ensure all entries returned are files
            var f = sfs.scoped(SFS_DIR, true),
                fileCnt = 0,
                foundFile = false,
                foundNonFile = false;
            f.eachFile('.', true, function(err, file, stat) {
                expect(!err).toBeTruthy();
                file = path.normalize(file).replace(/\\/g, '/');
                if (stat.isFile())
                {
                    ++fileCnt;
                    foundFile = true;
                }
                else
                {
                    foundNonFile = true;
                }
            }, function() {
                expect(foundFile).toBeTruthy();
                expect(foundNonFile).toBeFalsy();
                expect(fileCntInSfs).toBeLessThan(fileCnt); //compare against fs.readdirSync
                done();
            });
        });

    it("eachDirectory()",
        function(done) {
            //ensure all entries returned are files
            var f = sfs.scoped(SFS_DIR, true),
                foundDir = false,
                foundNonDir = false;
            f.eachDirectory('.', true, function(err, file, stat) {
                expect(!err).toBeTruthy();
                file = path.normalize(file).replace(/\\/g, '/');
                if (stat.isDirectory())
                {
                    foundDir = true;
                }
                else
                {
                    foundNonDir = true;
                }
            }, function() {
                expect(foundDir).toBeTruthy();
                expect(foundNonDir).toBeFalsy();
                done();
            });
        });

    it("eachFileMatching()",
        function(done) {
            //ensure all entries returned are files
            var f = sfs.scoped(SFS_DIR, true),
                foundMatch = false,
                foundBadFile = false;
            f.eachFileMatching(REGEX_PACKAGE_JSON, '.', true, function(err, file, stat) {
                expect(!err).toBeTruthy();
                if (file.match(REGEX_PACKAGE_JSON))
                {
                    foundMatch = true;
                    expect(stat).toBeDefined();
                }
                else
                {
                    foundBadFile = true;
                }
            }, function() {
                expect(foundMatch).toBeTruthy();
                expect(foundBadFile).toBeFalsy(); //should not have any files not matching the search expression
                done();
            });
        });

    it("readEachFileMatching()",
        function(done) {
            //ensure all entries returned are files
            var f = sfs.scoped(SFS_DIR, true),
                foundMatch = false,
                foundBadFile = false;
            f.readEachFileMatching(REGEX_PACKAGE_JSON, '.', true, function(err, file, stat, content) {
                expect(!err).toBeTruthy();
                if (file.match(REGEX_PACKAGE_JSON))
                {
                    foundMatch = true;
                    expect(stat).toBeDefined();
                    //all package.json are expected to be non-empty:
                    expect(content).toBeDefined();
                    expect(content.length).toBeGreaterThan(0);
                    var pkgName = REGEX_PKG_NAME.exec(file);
                    if (pkgName) //skip scopedfs' package.json
                    {
                        //try to match package.json content to expected name
                        expect(JSON.parse(content).name).toEqual(pkgName[1]);
                    }
                }
                else
                {
                    foundBadFile = true;
                }
            }, function() {
                expect(foundMatch).toBeTruthy();
                expect(foundBadFile).toBeFalsy(); //should not have any files not matching the search expression
                done();
            });
        });
});