/**
 * Changes:
 * > Modified readFile method to support caching of file.
 *   > Method signature is now readFile(relpath, encoding, cache, callback)
 *     > cache is optional to indicate whether to use cache. If true:
 *     > If file modification time has not changed and it exists in cache,
 *       the cached copy is returned.
 *       O.w. file is re-read, cached and returned.
 *   > Cache is global (and not per scoped instance).
 * > Changed default to '' instead of '/'.
 *   > '' gives access to all drives, whereas '/' gives access to current path.
 * > Added option to 'lock' to root folder. I.e. all relative paths provided
 *   will not be allowed to navigate above root folder.
 *   If an attempt is made to navigate above root folder (e.g. using '..'),
 *   no error will be thrown; the path will merely be resolved as far as possible,
 *   and capped to the root folder (and will most likely be non-existent).
 * > Added fileutils.
 * > JSLint refactoring.
 *
 * Based on scopedfs V0.1.0.
 *
 * @modified DS
 **/

//JSLint static code analysis options:
/*jslint node: true, continue:true, nomen:true, plusplus: true, sloppy: true, stupid: true, ass: true, todo: true, white: true, maxerr: 10, indent: 4 */

var Path = require('path'),
    fs = require('fs'),
    mkdirp = require('mkdirp'),
    rimraf = require('rimraf'),
    temp = require('temp'),
    fileutils = require('fileutils'),
    //For caching files read by readFile():
    cachedFiles = {},    //map of cached files: { <filename>"?"<timestamp>: {mtime: <file modified time>, data: <data>} }
    loadingFiles = {};   //map of files being loaded to interested parties: { <filename>"?"<timestamp>: [callback] }

function ScopedFS(path, locked)
{
    var k, v;
    this.path = path;
    this.locked = !!locked; //true means navigation above root folder is disallowed.
    for (k in this)
    {
        if (this.hasOwnProperty(k))
        {
            v = this[k];
            if (typeof v === 'function')
            {
                this[k] = v.bind(this);
            }
        }
    }
}

ScopedFS.prototype.rename = function(oldpath, newpath, callback) {
  return fs.rename(this.pathOf(oldpath), this.pathOf(newpath), callback);
};

ScopedFS.prototype.renameSync = function(oldpath, newpath) {
  return fs.renameSync(this.pathOf(oldpath), this.pathOf(newpath));
};

ScopedFS.prototype.stat = function(path, callback) {
  return fs.stat(this.pathOf(path), callback);
};

ScopedFS.prototype.statSync = function(path) {
  return fs.statSync(this.pathOf(path));
};

ScopedFS.prototype.chown = function(path, uid, gid, callback) {
  return fs.chown(this.pathOf(path), uid, gid, callback);
};

ScopedFS.prototype.chownSync = function(path, uid, gid) {
  return fs.chownSync(this.pathOf(path), uid, gid);
};

ScopedFS.prototype.lchown = function(path, uid, gid, callback) {
  return fs.lchown(this.pathOf(path), uid, gid, callback);
};

ScopedFS.prototype.lchownSync = function(path, uid, gid) {
  return fs.lchownSync(this.pathOf(path), uid, gid);
};

ScopedFS.prototype.chmod = function(path, mode, callback) {
  return fs.chmod(this.pathOf(path), mode, callback);
};

ScopedFS.prototype.chmodSync = function(path, mode) {
  return fs.chmodSync(this.pathOf(path), mode);
};

ScopedFS.prototype.lchmod = function(path, mode, callback) {
  return fs.lchmod(this.pathOf(path), mode, callback);
};

ScopedFS.prototype.lchmodSync = function(path, mode) {
  return fs.lchmodSync(this.pathOf(path), mode);
};

ScopedFS.prototype.lstat = function(path, callback) {
  return fs.lstat(this.pathOf(path), callback);
};

ScopedFS.prototype.lstatSync = function(path) {
  return fs.lstatSync(this.pathOf(path));
};

ScopedFS.prototype.link = function(srcpath, dstpath, callback) {
  return fs.link(this.pathOf(srcpath), this.pathOf(dstpath), callback);
};

ScopedFS.prototype.linkSync = function(srcpath, dstpath) {
  return fs.linkSync(this.pathOf(srcpath), this.pathOf(dstpath));
};

ScopedFS.prototype.symlink = function(srcpath, dstpath, type, callback) {
  return fs.symlink(this.pathOf(srcpath), this.pathOf(dstpath), type, callback);
};

ScopedFS.prototype.symlinkSync = function(srcpath, dstpath, type) {
  return fs.symlinkSync(this.pathOf(srcpath), this.pathOf(dstpath), type);
};

ScopedFS.prototype.readlink = function(path, callback) {
  return fs.readlink(this.pathOf(path), callback);
};

ScopedFS.prototype.readlinkSync = function(path) {
  return fs.readlinkSync(this.pathOf(path));
};

ScopedFS.prototype.realpath = function(path, cache, callback) {
  return fs.readlink(this.pathOf(path), cache, callback);
};

ScopedFS.prototype.realpathSync = function(path, cache) {
  return fs.readlinkSync(this.pathOf(path), cache);
};

ScopedFS.prototype.unlink = function(path, callback) {
  return fs.unlink(this.pathOf(path), callback);
};

ScopedFS.prototype.unlinkSync = function(path) {
  return fs.unlinkSync(this.pathOf(path));
};

ScopedFS.prototype.rmdir = function(path, callback) {
  return fs.rmdir(this.pathOf(path), callback);
};

ScopedFS.prototype.rmdirSync = function(path) {
  return fs.rmdirSync(this.pathOf(path));
};

ScopedFS.prototype.mkdir = function(path, mode, callback) {
  return fs.mkdir(this.pathOf(path), mode, callback);
};

ScopedFS.prototype.mkdirSync = function(path, mode) {
  return fs.mkdirSync(this.pathOf(path), mode);
};

ScopedFS.prototype.readdir = function(path, mode, callback) {
  return fs.readdir(this.pathOf(path), mode, callback);
};

ScopedFS.prototype.readdirSync = function(path, mode) {
  return fs.readdirSync(this.pathOf(path), mode);
};

/**
 * Asynchronus file read with optional caching.
 * @param cache (bool, optional) indicates whether to use cache.
 *   If true:
 *     If file modification time has not changed and it exists in cache,
 *     the cached copy is returned.
 *     O.w. file is re-read, cached and returned.
 *   O.w. plain old readFile is called.
 **/
ScopedFS.prototype.readFile = function(relpath, encoding, cache, callback) {
    function returnData(err, data, cb)
    {
        if (typeof cb === 'function')
        {
            if (err)
            {
                cb(err);
                return;
            }
            if (typeof data === 'string')
            {
                cb(false, data);
            }
            else //raw buffer
            {
                //return a copy of buffer
                var newBuf = new Buffer(data.length);
                data.copy(newBuf);
                cb(false, newBuf);
            }
        }
    }
    function returnData2All(key, data)
    {
        var waitingParties = loadingFiles[key],
            cnt, i;
        delete loadingFiles[key];
        if (waitingParties)
        {
            cnt = waitingParties.length;
            for (i = 0; i < cnt; ++i)
            {
                returnData(false, data, waitingParties[i]);
            }
        }
    }
    function returnError2All(key, err)
    {
        var waitingParties = loadingFiles[key],
            cnt, i, cb;
        delete loadingFiles[key];
        if (waitingParties)
        {
            cnt = waitingParties.length;
            for (i = 0; i < cnt; ++i)
            {
                cb = waitingParties[i];
                if (typeof cb === 'function')
                {
                    cb(err);
                }
            }
        }
    }

    //Validate inputs
    if (typeof encoding === 'function')
    {
        //only path & callback given as input parameters
        callback = encoding;
        encoding = null;
        cache = false;
    }
    else if (typeof encoding === 'boolean')
    {
        //path, cache & callback given as input parameters
        callback = cache;
        cache = encoding;
        encoding = null;
    }
    else
    {
        //only path, encoding & callback given as input parameters
        if (typeof cache === 'function')
        {
            callback = cache;
            cache = false;
        }
        else
        {
            cache = !!cache;
        }
    }
    if (typeof relpath !== 'string')
    {
        returnData('Bad argument: path must be a string!', null, callback);
        return;
    }
    var realpath = this.pathOf(relpath),
        key;
    if ((encoding !== null) && (typeof encoding === 'object'))
    {
        key = realpath + '?' + JSON.stringify(encoding);
    }
    else
    {
        if (typeof encoding !== 'string')
        {
            encoding = null;
        }
        key = realpath + '?' + encoding;
    }

    if (!cache)
    {
        //normal readFile call without caching:
        return fs.readFile(realpath, encoding, callback);
    }

    //readFile with caching:
    this.stat(relpath, function(err, stats) {
        if (err)
        {
            returnData(err, undefined, callback);
            return;
        }
        var mtime = stats.mtime.getTime(),
            waitingParties;
        if (!cachedFiles[key]
            || !cachedFiles[key].mtime
            || (mtime !== cachedFiles[key].mtime))
        {
            delete cachedFiles[key];
            waitingParties = loadingFiles[key];
            if (waitingParties === undefined) //start reload only if not already started
            {
                waitingParties = loadingFiles[key] = [];
                fs.readFile(realpath, encoding, function(err, data) {
                    if (err)
                    {
                        returnError2All(key, err);
                        return;
                    }
                    cachedFiles[key] = {
                        mtime: mtime,
                        data: data
                    };
                    returnData2All(key, data);
                });
            }
            waitingParties.push(callback); //register to get file data when it's loaded
        }
        else //already in cache and file not changed
        {
            returnData(false, cachedFiles[key].data, callback); //return copy from cache
        }
    });
};

/**
 * Purge all old cached files (read using readFile).
 * Reads in progress are not purged.
 **/
ScopedFS.prototype.purgeCache = function()
{
    var key;
    for (key in cachedFiles)
    {
        if (cachedFiles.hasOwnProperty(key) && (loadingFiles[key] === undefined))
        {
            delete cachedFiles[key];
        }
    }
};

ScopedFS.prototype.readFileSync = function(relpath, encoding) {
  return fs.readFileSync(this.pathOf(relpath), encoding);
};

ScopedFS.prototype.writeFile = function(relpath, data, encoding, callback) {
  return fs.writeFile(this.pathOf(relpath), data, encoding, callback);
};

ScopedFS.prototype.writeFileSync = function(relpath, data, encoding) {
  return fs.writeFileSync(this.pathOf(relpath), data, encoding);
};

ScopedFS.prototype.appendFile = function(relpath, data, encoding, callback) {
  return fs.appendFile(this.pathOf(relpath), data, encoding, callback);
};

ScopedFS.prototype.appendFileSync = function(relpath, data, encoding) {
  return fs.appendFileSync(this.pathOf(relpath), data, encoding);
};

ScopedFS.prototype.exists = function(path, callback) {
  return fs.exists(this.pathOf(path), callback);
};

ScopedFS.prototype.existsSync = function(path) {
  return fs.existsSync(this.pathOf(path));
};

ScopedFS.prototype.createReadStream = function(path, options) {
  return fs.createReadStream(this.pathOf(path), options);
};

ScopedFS.prototype.createWriteStream = function(path, options) {
  return fs.createWriteStream(this.pathOf(path), options);
};

ScopedFS.prototype.open = function(path, flags, mode, callback) {
  return fs.open(this.pathOf(path), flags, mode, callback);
};

ScopedFS.prototype.openSync = function(path, flags, mode) {
  return fs.openSync(this.pathOf(path), flags, mode);
};

ScopedFS.prototype.truncate = function(fd, len, callback) {
  return fs.truncate(fd, len, callback);
};

ScopedFS.prototype.truncateSync = function(fd, len) {
  return fs.truncateSync(fd, len);
};

ScopedFS.prototype.fchown = function(fd, uid, gid, callback) {
  return fs.fchown(fd, uid, gid, callback);
};

ScopedFS.prototype.fchownSync = function(fd, uid, gid) {
  return fs.fchownSync(fd, uid, gid);
};

ScopedFS.prototype.fchmod = function(fd, mode, callback) {
  return fs.fchmod(fd, mode, callback);
};

ScopedFS.prototype.fchmodSync = function(fd, mode) {
  return fs.fchmodSync(fd, mode);
};

ScopedFS.prototype.close = function(fd, callback) {
  return fs.close(fd, callback);
};

ScopedFS.prototype.closeSync = function(fd) {
  return fs.closeSync(fd);
};

ScopedFS.prototype.futimes = function(fd, atime, mtime, callback) {
  return fs.futimes(fd, atime, mtime, callback);
};

ScopedFS.prototype.futimesSync = function(fd, atime, mtime) {
  return fs.futimesSync(fd, atime, mtime);
};

ScopedFS.prototype.fsync = function(fd, callback) {
  return fs.fsync(fd, callback);
};

ScopedFS.prototype.fsyncSync = function(fd) {
  return fs.fsyncSync(fd);
};

ScopedFS.prototype.write = function(fd, buffer, offset, length, position, callback) {
  return fs.write(fd, buffer, offset, length, position, callback);
};

ScopedFS.prototype.writeSync = function(fd, buffer, offset, length, position) {
  return fs.writeSync(fd, buffer, offset, length, position);
};

ScopedFS.prototype.read = function(fd, buffer, offset, length, position, callback) {
  return fs.read(fd, buffer, offset, length, position, callback);
};

ScopedFS.prototype.readSync = function(fd, buffer, offset, length, position) {
  return fs.readSync(fd, buffer, offset, length, position);
};

ScopedFS.prototype.rmrf = function(path, callback) {
  return rimraf(this.pathOf(path), callback);
};

ScopedFS.prototype.rmrfSync = function(path) {
  return rimraf.sync(this.pathOf(path));
};

ScopedFS.prototype.mkdirp = function(path, mode, callback) {
  return mkdirp(this.pathOf(path), mode, callback);
};

ScopedFS.prototype.mkdirpSync = function(path, mode) {
  return mkdirp.sync(this.pathOf(path), mode);
};

ScopedFS.prototype.putSync = function(relpath, data, encoding) {
  this.mkdirpSync(Path.dirname(relpath));
  return this.writeFileSync(relpath, data, encoding);
};

ScopedFS.prototype.applySync = function(update) {
  var content, relpath, _results;
  _results = [];
  for (relpath in update) {
    if (update.hasOwnProperty(relpath))
    {
        content = update[relpath];
        if (typeof content === 'function') {
          _results.push(content(this.pathOf(relpath)));
        } else if (content !== null) {
          if (relpath.match(/\/$/)) {
            _results.push(this.mkdirpSync(relpath.replace(/\/$/, '')));
          } else {
            _results.push(this.putSync(relpath, content));
          }
        } else {
          _results.push(this.rmrfSync(relpath, content));
        }
    }
  }
  return _results;
};

ScopedFS.prototype.eachFile = function(path, recurse, callback, completeHandler)
{
    return fileutils.eachFile(this.pathOf(path), recurse, callback, completeHandler);
};
ScopedFS.prototype.eachDirectory = function(path, recurse, callback, completeHandler)
{
    return fileutils.eachDirectory(this.pathOf(path), recurse, callback, completeHandler);
};
ScopedFS.prototype.eachFileMatching = function(expression, path, recurse, callback, completeHandler)
{
    return fileutils.eachFileMatching(expression, this.pathOf(path), recurse, callback, completeHandler);
};
ScopedFS.prototype.eachFileOrDirectory = function(directory, recurse, fileHandler, completeHandler)
{
    return fileutils.eachFileOrDirectory(this.pathOf(directory), recurse, fileHandler, completeHandler);
};
ScopedFS.prototype.readEachFileMatching = function(expression, path, recurse, callback, completeHandler)
{
    return fileutils.readEachFileMatching(expression, this.pathOf(path), recurse, callback, completeHandler);
};

ScopedFS.prototype.pathOf = function(relpath) {
    return Path.join(this.path, !this.locked? relpath:
        //SD: if locked, disallow navigation above root path:
        Path.normalize(Path.sep + relpath));
};

ScopedFS.prototype.scoped = function(relpath, locked) {
    return new ScopedFS(this.pathOf(relpath || ''), locked);
};

ScopedFS.prototype.createTempFS = function(affixes) {
    return new ScopedFS(temp.mkdirSync(affixes));
};

//SD: changed default from '/' to '', so we won't be locked to Node.JS drive or lalaland.
module.exports = new ScopedFS('');
module.exports.ScopedFS = ScopedFS;
